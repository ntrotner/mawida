/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"errors"
	"net/http"
	openapi "template_backend/open-api/authentication"
	models "template_backend/open-api/models"
	"time"

	database_location "template_backend/database/paths/location"
	database_product "template_backend/database/paths/product"
	database_rent_contract "template_backend/database/paths/rent_contract"

	"github.com/rs/zerolog/log"
)

// ProductAPIService is a service that implements the logic for the ProductAPIServicer
// This service should implement the business logic for every endpoint for the ProductAPI API.
// Include any external packages or services that will be required by this service.
type ProductAPIService struct {
}

// NewProductAPIService creates a default api service
func NewProductAPIService() ProductAPIServicer {
	return &ProductAPIService{}
}

// ProductsGet - Retrieve all products
func (s *ProductAPIService) ProductsGet(ctx context.Context, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsUserAuthorized(ctx, r)
	admin, _ := openapi.IsAdmin(ctx, r)

	if admin == nil && user == nil {
		sanitizedProducts := database_product.GetAllProducts(ctx)
		for i := range sanitizedProducts {
			database_product.SanitizeProduct(&sanitizedProducts[i])
		}
		return models.Response(200, sanitizedProducts), nil
	}

	if admin == nil && user != nil {
		products := database_product.GetAllProducts(ctx)
		for i := range products {
			if products[i].RenterInfo != nil && products[i].RenterInfo.UserID != user.ID {
				database_product.SanitizeProduct(&products[i])
			} else {
				renterInfo := products[i].RenterInfo
				database_product.SanitizeProduct(&products[i])
				products[i].RenterInfo = renterInfo
			}
		}
		return models.Response(200, products), nil
	}

	products := database_product.GetAllProducts(ctx)
	return models.Response(200, products), nil
}

// ProductsPost - Create a new product
func (s *ProductAPIService) ProductsPost(ctx context.Context, product models.Product, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsAdmin(ctx, r)

	if user == nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Forbidden. Admin access required."}}}), nil
	}

	// Convert OpenAPI model to database model
	images := make([]database_product.ProductImage, len(product.Images))
	for i, img := range product.Images {
		images[i] = database_product.ProductImage{
			ID:   img.ID,
			Name: img.Name,
			Data: img.Data,
		}
	}

	documents := make([]database_product.ProductDocument, len(product.Documents))
	for i, doc := range product.Documents {
		documents[i] = database_product.ProductDocument{
			ID:   doc.ID,
			Name: doc.Name,
			Data: doc.Data,
		}
	}

	pricing := database_product.ProductPricing{
		Price:   product.Pricing.Price,
		Deposit: product.Pricing.Deposit,
	}

	dbProduct := database_product.CreateProduct(
		ctx,
		product.Name,
		product.Description,
		product.Location,
		pricing,
		images,
		documents,
		product.DynamicAttributes,
	)
	if dbProduct == nil {
		log.Error().Msg("Failed to create product")
		return models.Response(400, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create product"}}}), nil
	}

	response := models.Product{
		ID:          dbProduct.ID,
		Name:        dbProduct.Name,
		Description: dbProduct.Description,
		Location:    dbProduct.Location,
		Pricing: models.ProductPricing{
			Price:   dbProduct.Pricing.Price,
			Deposit: dbProduct.Pricing.Deposit,
		},
		DynamicAttributes: dbProduct.DynamicAttributes,
		Images:            make([]models.ProductImagesInner, len(dbProduct.Images)),
		Documents:         make([]models.ProductDocumentsInner, len(dbProduct.Documents)),
	}
	for _, img := range dbProduct.Images {
		response.Images = append(response.Images, models.ProductImagesInner{
			ID:   img.ID,
			Name: img.Name,
			Data: img.Data,
		})
	}
	for _, doc := range dbProduct.Documents {
		response.Documents = append(response.Documents, models.ProductDocumentsInner{
			ID:   doc.ID,
			Name: doc.Name,
			Data: doc.Data,
		})
	}

	return models.Response(201, response), nil
}

// ProductsProductIdDelete - Delete a single product
func (s *ProductAPIService) ProductsProductIdDelete(ctx context.Context, productId string) (models.ImplResponse, error) {
	// TODO - update ProductsProductIdDelete with the required logic for this service method.
	// Add api_product_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Success{}) or use other options such as http.Ok ...
	// return Response(200, Success{}), nil

	// TODO: Uncomment the next line to return response Response(404, Error{}) or use other options such as http.Ok ...
	// return Response(404, Error{}), nil

	// TODO: Uncomment the next line to return response Response(401, Error{}) or use other options such as http.Ok ...
	// return Response(401, Error{}), nil

	return models.Response(http.StatusNotImplemented, nil), errors.New("ProductsProductIdDelete method not implemented")
}

// ProductsProductIdGet - Retrieve a single product
func (s *ProductAPIService) ProductsProductIdGet(ctx context.Context, productId string, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsUserAuthorized(ctx, r)
	admin, _ := openapi.IsAdmin(ctx, r)

	if admin == nil && user == nil {
		sanitizedProduct := database_product.FindProductById(ctx, productId)
		if sanitizedProduct == nil {
			return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product not found"}}}), nil
		}

		database_product.SanitizeProduct(sanitizedProduct)
		return models.Response(200, sanitizedProduct), nil
	}

	if admin == nil && user != nil {
		product := database_product.FindProductById(ctx, productId)
		if product == nil {
			return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product not found"}}}), nil
		}

		if product.RenterInfo != nil && product.RenterInfo.UserID != user.ID {
			database_product.SanitizeProduct(product)
		} else {
			renterInfo := product.RenterInfo
			database_product.SanitizeProduct(product)
			product.RenterInfo = renterInfo
		}

		return models.Response(200, product), nil
	}

	product := database_product.FindProductById(ctx, productId)
	return models.Response(200, product), nil
}

// ProductsProductIdRentPost - Rent a product
func (s *ProductAPIService) ProductsProductIdRentPost(ctx context.Context, productId string, rentProductFormular models.RentProductFormular, r *http.Request) (models.ImplResponse, error) {
	user, err := openapi.IsConfirmedUser(ctx, r)
	if err != nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Unauthorized. Only confirmed users can rent products."}}}), nil
	}

	// Get product from database
	product := database_product.FindProductById(ctx, productId)
	if product == nil || product.IsRented {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product is unavailable"}}}), nil
	}

	// Check if location is available and exists for product
	location := database_location.FindLocationById(ctx, rentProductFormular.LocationId)
	if location == nil || product.Location != rentProductFormular.LocationId {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Location not found"}}}), nil
	}

	// Only allow start date to be today
	startDate := time.Unix(rentProductFormular.RentalStartDate, 0)
	endDate := time.Unix(rentProductFormular.RentalEndDate, 0)
	days := int(endDate.Sub(startDate).Hours() / 24)
	today := time.Now()
	todayAtZero := time.Date(today.Year(), today.Month(), today.Day(), 0, 0, 0, 0, today.Location())
	tomorrow := todayAtZero.AddDate(0, 0, 1)
	tomorrowAtZero := time.Date(tomorrow.Year(), tomorrow.Month(), tomorrow.Day(), 0, 0, 0, 0, tomorrow.Location())
	if !(startDate.After(todayAtZero) && startDate.Before(tomorrowAtZero)) {
		return models.Response(400, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Start date cannot be in the past or in the future"}}}), nil
	}

	// Calculate total amount
	totalAmount := database_product.CalculateTotalAmount(product, days)

	// Create rent contract
	contract := database_rent_contract.CreateRentContract(
		ctx,
		productId,
		user.ID,
		rentProductFormular.RentalStartDate,
		rentProductFormular.RentalEndDate,
		product.Pricing.Price,
		product.Pricing.Deposit,
		totalAmount,
		rentProductFormular.PaymentMethodId,
		rentProductFormular.LocationId,
		rentProductFormular.LocationId,
		rentProductFormular.AdditionalNotes,
		rentProductFormular.DynamicAttributes,
	)

	if contract == nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "001", Message: "Failed to create rent contract"}}}), nil
	}

	// Update product rental status
	product.IsRented = true
	product.RenterInfo = &database_product.RenterInfo{
		UserID:          user.ID,
		RentalStartDate: rentProductFormular.RentalStartDate,
		RentalEndDate:   rentProductFormular.RentalEndDate,
	}

	updatedProduct := database_product.UpdateProduct(ctx, product)
	if updatedProduct == nil {
		// Rollback rent contract creation
		database_rent_contract.DeleteRentContract(ctx, contract.ID, contract.Rev)
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "001", Message: "Failed to update product rental status"}}}), nil
	}

	response := models.RentProductConfirmation{
		RentContractId: contract.ID,
	}

	return models.Response(200, response), nil
}

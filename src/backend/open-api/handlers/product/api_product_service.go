/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"
	"strings"
	"template_backend/core/config"
	"template_backend/infrastructure/payment"
	paymentTypes "template_backend/infrastructure/payment/types"
	openapi "template_backend/open-api/authentication"
	models "template_backend/open-api/models"
	"time"

	database_location "template_backend/database/paths/location"
	database_payments "template_backend/database/paths/payments"
	database_product "template_backend/database/paths/product"
	database_rent_contract "template_backend/database/paths/rent_contract"

	"github.com/rs/zerolog/log"
	"github.com/stripe/stripe-go/v82"
)

// ProductAPIService is a service that implements the logic for the ProductAPIServicer
// This service should implement the business logic for every endpoint for the ProductAPI API.
// Include any external packages or services that will be required by this service.
type ProductAPIService struct {
}

// NewProductAPIService creates a default api service
func NewProductAPIService() ProductAPIServicer {
	return &ProductAPIService{}
}

// ProductsGet - Retrieve all products
func (s *ProductAPIService) ProductsGet(ctx context.Context, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsUserAuthorized(ctx, r)
	admin, _ := openapi.IsAdmin(ctx, r)
	products := database_product.GetAllProducts(ctx)

	if admin == nil && user == nil {
		for i := range products {
			database_product.SanitizeProduct(&products[i])
		}
	}

	if admin == nil && user != nil {
		for i := range products {
			renterInfo := products[i].RenterInfo
			database_product.SanitizeProduct(&products[i])

			if products[i].RenterInfo.UserID == user.ID {
				products[i].RenterInfo = renterInfo
			}
		}
	}

	return models.Response(200, products), nil
}

// ProductsPost - Create a new product
func (s *ProductAPIService) ProductsPost(ctx context.Context, product models.Product, r *http.Request) (models.ImplResponse, error) {
	// Check admin authorization
	admin, _ := openapi.IsAdmin(ctx, r)
	if admin == nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Forbidden. Admin access required."}}}), nil
	}

	// Convert OpenAPI model to database model
	images := make([]database_product.ProductImage, len(product.Images))
	for i, img := range product.Images {
		images[i] = database_product.ProductImage{
			ID:   img.ID,
			Name: img.Name,
			Data: img.Data,
		}
	}
	documents := make([]database_product.ProductDocument, len(product.Documents))
	for i, doc := range product.Documents {
		documents[i] = database_product.ProductDocument{
			ID:   doc.ID,
			Name: doc.Name,
			Data: doc.Data,
		}
	}
	pricing := database_product.ProductPricing{
		Price:   product.Pricing.Price,
		Deposit: product.Pricing.Deposit,
	}

	// Create payment product
	paymentProduct := payment.ProductData{
		Name:        product.Name,
		Description: product.Description,
	}
	createdPaymentProduct, err := payment.CreateProduct(paymentProduct)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create payment product")
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create product"}}}), nil
	}
	// Create payment price
	paymentPrice := payment.PriceData{
		Currency:   "eur",
		UnitAmount: product.Pricing.Price,
		Metadata: map[string]string{
			"refundable": "false",
		},
	}
	createdPaymentPrice, priceErr := payment.CreatePrice(createdPaymentProduct.ID, paymentPrice)
	if priceErr != nil {
		log.Error().Err(priceErr).Msg("Failed to create payment price")

		_, deleteErr := payment.DeleteProduct(createdPaymentProduct.ID)
		if deleteErr != nil {
			log.Error().Err(deleteErr).Msg("Failed to delete payment product")
		}

		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create price"}}}), nil
	}

	depositProduct := payment.ProductData{
		Name:        strings.Join([]string{product.Name, "Deposit"}, " - "),
		Description: "Deposit",
	}
	createdDepositProduct, err := payment.CreateProduct(depositProduct)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create deposit product")
		_, deleteErr := payment.DeleteProduct(createdPaymentProduct.ID)
		if deleteErr != nil {
			log.Error().Err(deleteErr).Msg("Failed to delete payment product")
		}

		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create product"}}}), nil
	}
	paymentDeposit := payment.PriceData{
		Currency:   "eur",
		UnitAmount: product.Pricing.Deposit,
		Metadata: map[string]string{
			"refundable": "true",
		},
	}
	createdPaymentDeposit, depositErr := payment.CreatePrice(createdDepositProduct.ID, paymentDeposit)
	if depositErr != nil {
		log.Error().Err(depositErr).Msg("Failed to create payment price or deposit")

		_, deleteErr := payment.DeleteProduct(createdPaymentProduct.ID)
		if deleteErr != nil {
			log.Error().Err(deleteErr).Msg("Failed to delete payment product")
		}

		_, deleteErr = payment.DeleteProduct(createdDepositProduct.ID)
		if deleteErr != nil {
			log.Error().Err(deleteErr).Msg("Failed to delete deposit product")
		}

		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create price"}}}), nil
	}

	// Create database product
	productIdentifier := &paymentTypes.ProductIdentifier{
		ID:        createdPaymentProduct.ID,
		Mode:      "payment",
		PriceID:   createdPaymentPrice.ID,
		DepositID: createdPaymentDeposit.ID,
	}
	dbProduct := database_product.CreateProduct(
		ctx,
		product.Name,
		product.Description,
		product.Location,
		pricing,
		images,
		documents,
		productIdentifier,
		product.DynamicAttributes,
	)
	if dbProduct == nil {
		// Rollback payment product and price creation
		_, deleteErr := payment.DeleteProduct(createdPaymentProduct.ID)
		if deleteErr != nil {
			log.Error().Err(deleteErr).Msg("Failed to rollback payment product creation after database product creation failure")
		}

		log.Error().Msg("Failed to create database product")
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create product in database"}}}), nil
	}

	// Build response
	response := models.Product{
		ID:          dbProduct.ID,
		Name:        dbProduct.Name,
		Description: dbProduct.Description,
		Location:    dbProduct.Location,
		Pricing: models.ProductPricing{
			Price:   dbProduct.Pricing.Price,
			Deposit: dbProduct.Pricing.Deposit,
		},
		DynamicAttributes: dbProduct.DynamicAttributes,
		Images:            []models.ProductImagesInner{},
		Documents:         []models.ProductDocumentsInner{},
	}

	// Add images and documents to response
	for i := range dbProduct.Images {
		response.Images = append(response.Images, models.ProductImagesInner{
			ID:   dbProduct.Images[i].ID,
			Name: dbProduct.Images[i].Name,
			Data: dbProduct.Images[i].Data,
		})
	}
	for i := range dbProduct.Documents {
		response.Documents = append(response.Documents, models.ProductDocumentsInner{
			ID:   dbProduct.Documents[i].ID,
			Name: dbProduct.Documents[i].Name,
			Data: dbProduct.Documents[i].Data,
		})
	}

	return models.Response(201, response), nil
}

// ProductsProductIdDelete - Delete a single product
func (s *ProductAPIService) ProductsProductIdDelete(ctx context.Context, productId string, r *http.Request) (models.ImplResponse, error) {
	admin, _ := openapi.IsAdmin(ctx, r)

	if admin == nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Forbidden. Admin access required."}}}), nil
	}

	product := database_product.FindProductById(ctx, productId)
	if product == nil {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product not found"}}}), nil
	}

	_, deleteErr := payment.DeleteProduct(product.ProductIdentifier.ID)
	if deleteErr != nil {
		log.Error().Err(deleteErr).Msg("Failed to delete payment product")
	}

	_, deleteErr = payment.DeleteProduct(product.ProductIdentifier.DepositID)
	if deleteErr != nil {
		log.Error().Err(deleteErr).Msg("Failed to delete deposit product")
	}

	return models.Response(200, models.Success{}), nil
}

// ProductsProductIdGet - Retrieve a single product
func (s *ProductAPIService) ProductsProductIdGet(ctx context.Context, productId string, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsUserAuthorized(ctx, r)
	admin, _ := openapi.IsAdmin(ctx, r)
	product := database_product.FindProductById(ctx, productId)

	if product == nil {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product not found"}}}), nil
	}

	if admin == nil && user == nil {
		database_product.SanitizeProduct(product)
	}

	if admin == nil && user != nil {
		renterInfo := product.RenterInfo
		database_product.SanitizeProduct(product)

		if product.RenterInfo.UserID == user.ID {
			product.RenterInfo = renterInfo
		}
	}

	return models.Response(200, product), nil
}

// ProductsProductIdRentPost - Rent a product
func (s *ProductAPIService) ProductsProductIdRentPost(ctx context.Context, productId string, rentProductFormular models.RentProductFormular, r *http.Request) (models.ImplResponse, error) {
	user, err := openapi.IsConfirmedUser(ctx, r)
	if err != nil {
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Unauthorized. Only confirmed users can rent products."}}}), nil
	}

	// Get product from database
	product := database_product.FindProductById(ctx, productId)
	if product == nil || product.IsRented {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Product is unavailable"}}}), nil
	}

	// Check if location is available and exists for product
	location := database_location.FindLocationById(ctx, rentProductFormular.LocationId)
	if location == nil || product.Location != rentProductFormular.LocationId {
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Location not found or invalid for this product"}}}), nil
	}

	// Only allow start date to be today
	startDate := time.Unix(rentProductFormular.RentalStartDate, 0)
	endDate := time.Unix(rentProductFormular.RentalEndDate, 0)
	days := int(endDate.Sub(startDate).Hours() / 24)
	if days <= 0 {
		return models.Response(400, models.Error{ErrorMessages: []models.Message{{Code: "201", Message: "Rental end date must be after start date."}}}), nil
	}
	today := time.Now()
	todayAtZero := time.Date(today.Year(), today.Month(), today.Day(), 0, 0, 0, 0, today.Location())
	tomorrow := todayAtZero.AddDate(0, 0, 1)
	tomorrowAtZero := time.Date(tomorrow.Year(), tomorrow.Month(), tomorrow.Day(), 0, 0, 0, 0, tomorrow.Location())
	if !(startDate.After(todayAtZero) && startDate.Before(tomorrowAtZero)) {
		return models.Response(400, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Start date must be today."}}}), nil
	}

	paymentTransaction, err := database_payments.InitializePaymentTransaction(ctx, user.CustomerIdentifier.ID, product.ProductIdentifier.ID, product.Pricing.Price, product.Pricing.Deposit, product.ProductIdentifier.Mode)
	if err != nil {
		log.Error().Err(err).Msg("Failed to initialize payment transaction")
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "001", Message: "Failed to initiate payment session"}}}), nil
	}

	// Payment Method Handling
	var checkoutSession *paymentTypes.CheckoutSessionIdentifier
	var stripeCheckoutSession *stripe.CheckoutSession
	paymentMethod := rentProductFormular.PaymentMethodId
	isCashPayment := (paymentMethod == models.CASH)

	if !isCashPayment {
		log.Info().Interface("ProductIdentifier", product.ProductIdentifier).Msg("Product identifier")
		log.Info().Str("ProductID", product.ProductIdentifier.ID).Msg("Creating checkout session for online payment")
		stripeCheckoutSession, err = payment.CreateCheckoutSession(payment.CheckoutSessionConfig{
			CustomerID: user.CustomerIdentifier.ID,
			SuccessURL: config.GlobalConfig.Stripe.SuccessURL + "?productId=" + productId + "&success=true",
			CancelURL:  config.GlobalConfig.Stripe.CancelURL + "?productId=" + productId + "&success=false",
			Mode:       product.ProductIdentifier.Mode,
			Items: []payment.CheckoutItem{
				{PriceID: product.ProductIdentifier.PriceID, Quantity: int64(days)},
				{PriceID: product.ProductIdentifier.DepositID, Quantity: 1},
			},
			Metadata: map[string]string{
				"paymentTransactionID": paymentTransaction.ID,
			},
		})
		if err != nil {
			log.Error().Err(err).Msg("Failed to create checkout session")
			return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "001", Message: "Failed to initiate payment session"}}}), nil
		}

		checkoutSession = &paymentTypes.CheckoutSessionIdentifier{ID: stripeCheckoutSession.ID}
		log.Info().Str("SessionID", checkoutSession.ID).Msg("Checkout session created")
	} else {
		log.Info().Msg("Processing cash payment, skipping Stripe checkout session creation")
	}

	// Calculate total amount
	totalAmount := database_product.CalculateTotalAmount(product, days)

	paymentInstruction := &database_rent_contract.PaymentInstruction{
		PaymentMethodID:   database_rent_contract.PaymentMethod(rentProductFormular.PaymentMethodId),
		DynamicAttributes: map[string]interface{}{},
	}

	if stripeCheckoutSession != nil && !isCashPayment {
		paymentInstruction.DynamicAttributes["url"] = stripeCheckoutSession.URL
	}

	// Create rent contract
	contract := database_rent_contract.CreateRentContract(
		ctx,
		productId,
		user.ID,
		rentProductFormular.RentalStartDate,
		rentProductFormular.RentalEndDate,
		product.Pricing.Price,
		product.Pricing.Deposit,
		totalAmount,
		string(rentProductFormular.PaymentMethodId),
		rentProductFormular.LocationId,
		rentProductFormular.LocationId,
		rentProductFormular.AdditionalNotes,
		checkoutSession,
		rentProductFormular.DynamicAttributes,
		paymentInstruction,
	)

	if contract == nil {
		log.Error().Msg("Failed to create rent contract in database")
		if checkoutSession != nil {
			_, deleteErr := payment.DeleteCheckoutSession(checkoutSession.ID)
			if deleteErr != nil {
				log.Error().Err(deleteErr).Str("SessionID", checkoutSession.ID).Msg("Failed to delete/rollback checkout session")
			}
		}

		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "301", Message: "Failed to create rent contract"}}}), nil
	}
	log.Info().Str("ContractID", contract.ID).Msg("Rent contract created successfully")

	// Update Product Rental Status
	product.IsRented = true
	product.RenterInfo = database_product.RenterInfo{
		UserID:          user.ID,
		RentalStartDate: rentProductFormular.RentalStartDate,
		RentalEndDate:   rentProductFormular.RentalEndDate,
	}

	updatedProduct := database_product.UpdateProduct(ctx, product)
	if updatedProduct == nil {
		log.Error().Str("ProductID", productId).Msg("Failed to update product rental status")

		// Rollback: Delete Rent Contract
		deleted := database_rent_contract.DeleteRentContract(ctx, contract.ID, contract.Rev)
		if !deleted {
			log.Error().Str("ContractID", contract.ID).Msg("Failed to rollback rent contract deletion")
		}

		// Rollback: Delete Checkout Session (if created)
		if checkoutSession != nil {
			_, deleteErr := payment.DeleteCheckoutSession(checkoutSession.ID)
			if deleteErr != nil {
				log.Error().Err(deleteErr).Str("SessionID", checkoutSession.ID).Msg("Failed to delete/rollback checkout session")
			}
		}

		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "302", Message: "Failed to update product rental status"}}}), nil
	}
	log.Info().Str("ProductID", productId).Msg("Product rental status updated successfully")

	response := models.RentProductConfirmation{
		RentContractId: contract.ID,
	}

	return models.Response(200, response), nil
}

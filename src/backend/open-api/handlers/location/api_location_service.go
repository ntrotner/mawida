/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"net/http"

	database_location "template_backend/database/paths/location"
	openapi "template_backend/open-api/authentication"
	models "template_backend/open-api/models"

	"github.com/rs/zerolog/log"
)

// LocationAPIService is a service that implements the logic for the LocationAPIServicer
// This service should implement the business logic for every endpoint for the LocationAPI API.
// Include any external packages or services that will be required by this service.
type LocationAPIService struct {
}

// NewLocationAPIService creates a default api service
func NewLocationAPIService() LocationAPIServicer {
	return &LocationAPIService{}
}

// LocationLocationIdGet - Retrieve a single location
func (s *LocationAPIService) LocationLocationIdGet(ctx context.Context, locationId string) (models.ImplResponse, error) {
	location := database_location.FindLocationById(ctx, locationId)
	if location == nil {
		log.Error().Str("id", locationId).Msg("Location not found")
		return models.Response(404, models.Error{ErrorMessages: []models.Message{{Code: "404", Message: "Location not found"}}}), nil
	}

	// reformat location to comply with the openapi schema
	formattedLocation := models.Location{
		ID:           location.ID,
		City:         location.City,
		Street:       location.Street,
		PostalCode:   location.PostalCode,
		BuildingName: location.BuildingName,
		Coordinates: models.LocationCoordinates{
			Longitude: float32(location.Longitude),
			Latitude:  float32(location.Latitude),
		},
		Notes: location.Notes,
	}

	return models.Response(200, formattedLocation), nil
}

// LocationsGet - Retrieve all locations
func (s *LocationAPIService) LocationsGet(ctx context.Context) (models.ImplResponse, error) {
	locations := database_location.GetAllLocations(ctx)
	if locations == nil {
		log.Error().Msg("Failed to retrieve locations")
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "001", Message: "Internal server error"}}}), nil
	}

	// reformat locations to comply with the openapi schema
	formattedLocations := make([]models.Location, len(locations))
	for i, location := range locations {
		formattedLocations[i] = models.Location{
			ID:           location.ID,
			City:         location.City,
			Street:       location.Street,
			PostalCode:   location.PostalCode,
			BuildingName: location.BuildingName,
			Coordinates: models.LocationCoordinates{
				Longitude: float32(location.Longitude),
				Latitude:  float32(location.Latitude),
			},
			Notes: location.Notes,
		}
	}

	return models.Response(200, formattedLocations), nil
}

// LocationsPost - Create a new location
func (s *LocationAPIService) LocationsPost(ctx context.Context, location models.Location, r *http.Request) (models.ImplResponse, error) {
	user, _ := openapi.IsAdmin(ctx, r)

	if user == nil {
		log.Error().Msg("User is not an admin")
		return models.Response(401, models.Error{ErrorMessages: []models.Message{{Code: "100", Message: "Forbidden. Admin access required."}}}), nil
	}

	err := database_location.CreateLocation(
		ctx,
		location.ID,
		location.City,
		location.Street,
		location.PostalCode,
		location.BuildingName,
		float64(location.Coordinates.Latitude),
		float64(location.Coordinates.Longitude),
		location.Notes,
	)
	if err != nil {
		log.Error().Msg("Failed to create location")
		return models.Response(400, models.Error{ErrorMessages: []models.Message{{Code: "200", Message: "Failed to create location"}}}), nil
	}

	return models.Response(201, models.Success{}), nil
}

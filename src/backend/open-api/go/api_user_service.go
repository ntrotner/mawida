/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"errors"
	"net/http"
	database_location "template_backend/database/paths/location"
	database_product "template_backend/database/paths/product"
	database_rent_contract "template_backend/database/paths/rent_contract"
	database_user "template_backend/database/paths/user"
	openapi_common "template_backend/open-api/common"

	"time"

	"github.com/rs/zerolog/log"
)

// UserAPIService is a service that implements the logic for the UserAPIServicer
// This service should implement the business logic for every endpoint for the UserAPI API.
// Include any external packages or services that will be required by this service.
type UserAPIService struct {
}

// NewUserAPIService creates a default api service
func NewUserAPIService() UserAPIServicer {
	return &UserAPIService{}
}

// ChangeEmailPost - Change user email
func (s *UserAPIService) ChangeEmailPost(ctx context.Context, changeEmail ChangeEmail, r *http.Request) (ImplResponse, error) {
	token, found := openapi_common.ReadTokenFromHeader(r)
	if !found {
		log.Error().Msg("Bearer format invalid")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	_, content, err := database_user.VerifyJWT(&token)
	if err != nil {
		log.Error().Msg("Couldn't verify token to refresh")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	_, err = database_user.ChangeUserEmail(ctx, &content.ID, &changeEmail.NewEmail)
	if err != nil {
		log.Error().Str("id", content.ID).Msg("Couldn't update email for user")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	return Response(200, Success{}), nil
}

// ChangePasswordPost - Change user password
func (s *UserAPIService) ChangePasswordPost(ctx context.Context, changePassword ChangePassword, r *http.Request) (ImplResponse, error) {
	token, found := openapi_common.ReadTokenFromHeader(r)
	if !found {
		log.Error().Msg("Bearer format invalid")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	_, content, err := database_user.VerifyJWT(&token)
	if err != nil {
		log.Error().Msg("Couldn't verify token to refresh")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	user := database_user.AuthenticateUserById(ctx, content.ID, changePassword.CurrentPassword)
	if user == nil {
		log.Error().Str("id", content.ID).Msg("Couldn't find user by id")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	_, err = database_user.ChangeUserPassword(ctx, &content.ID, &changePassword.NewPassword)
	if err != nil {
		log.Error().Str("id", content.ID).Msg("Couldn't update email for user")
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized. Please check your credentials."}}}), nil
	}

	return Response(200, Success{}), nil
}

// LocationLocationIdGet - Retrieve a single location
func (s *UserAPIService) LocationLocationIdGet(ctx context.Context, locationId string) (ImplResponse, error) {
	location := database_location.FindLocationById(ctx, locationId)
	if location == nil {
		log.Error().Str("id", locationId).Msg("Location not found")
		return Response(404, Error{ErrorMessages: []Message{{Code: "404", Message: "Location not found"}}}), nil
	}

	// reformat location to comply with the openapi schema
	formattedLocation := Location{
		Id:           location.ID,
		City:         location.City,
		Street:       location.Street,
		PostalCode:   location.PostalCode,
		BuildingName: location.BuildingName,
		Coordinates: LocationCoordinates{
			Longitude: float32(location.Longitude),
			Latitude:  float32(location.Latitude),
			Notes:     location.Notes,
		},
	}

	return Response(200, formattedLocation), nil
}

// LocationsGet - Retrieve all locations
func (s *UserAPIService) LocationsGet(ctx context.Context) (ImplResponse, error) {
	locations := database_location.GetAllLocations(ctx)
	if locations == nil {
		log.Error().Msg("Failed to retrieve locations")
		return Response(500, Error{ErrorMessages: []Message{{Code: "500", Message: "Internal server error"}}}), nil
	}

	// reformat locations to comply with the openapi schema
	formattedLocations := make([]Location, len(locations))
	for i, location := range locations {
		formattedLocations[i] = Location{
			Id:           location.ID,
			City:         location.City,
			Street:       location.Street,
			PostalCode:   location.PostalCode,
			BuildingName: location.BuildingName,
			Coordinates: LocationCoordinates{
				Longitude: float32(location.Longitude),
				Latitude:  float32(location.Latitude),
				Notes:     location.Notes,
			},
		}
	}

	return Response(200, formattedLocations), nil
}

// PasswordResetPost - Initiate password reset
func (s *UserAPIService) PasswordResetPost(ctx context.Context, passwordReset PasswordReset) (ImplResponse, error) {
	// TODO - update PasswordResetPost with the required logic for this service method.
	// Add api_user_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Success{}) or use other options such as http.Ok ...
	// return Response(200, Success{}), nil

	// TODO: Uncomment the next line to return response Response(400, Error{}) or use other options such as http.Ok ...
	// return Response(400, Error{}), nil

	// TODO: Uncomment the next line to return response Response(401, Error{}) or use other options such as http.Ok ...
	// return Response(401, Error{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("PasswordResetPost method not implemented")
}

// ProductsProductIdGet - Retrieve a single product
func (s *UserAPIService) ProductsProductIdGet(ctx context.Context, productId string, r *http.Request) (ImplResponse, error) {
	// if not authenticated then a sanitized version is send
	token, found := openapi_common.ReadTokenFromHeader(r)
	sanitizedProduct := database_product.Product{}
	if !found {
		sanitizedProduct = *database_product.FindProductById(ctx, productId)
		sanitizedProduct.DynamicAttributes = nil
		sanitizedProduct.RenterInfo = nil
		return Response(200, sanitizedProduct), nil
	}

	_, content, err := database_user.VerifyJWT(&token)
	if err != nil {
		log.Error().Msg("Couldn't verify token")
		return Response(200, sanitizedProduct), nil
	}

	user := database_user.FindUserById(ctx, &content.ID)
	if user == nil {
		log.Error().Str("id", content.ID).Msg("User not found")
		return Response(200, sanitizedProduct), nil
	}

	if user.Roles != database_user.AdminUser {
		log.Error().Str("id", content.ID).Msg("User is not an admin")
		return Response(200, sanitizedProduct), nil
	}

	product := database_product.FindProductById(ctx, productId)
	return Response(200, product), nil
}

// ProductsProductIdRentPost - Rent a product
func (s *UserAPIService) ProductsProductIdRentPost(ctx context.Context, productId string, rentProductFormular RentProductFormular, r *http.Request) (ImplResponse, error) {
	// Read token from request header
	token, found := openapi_common.ReadTokenFromHeader(r)
	if !found {
		log.Error().Msg("Bearer format invalid")
		return Response(http.StatusUnauthorized, Error{
			ErrorMessages: []Message{
				{
					Code:    "100",
					Message: "Unauthorized. Please check your credentials.",
				},
			},
		}), nil
	}

	// Verify JWT token
	_, content, err := database_user.VerifyJWT(&token)
	if err != nil {
		log.Error().Msg("Couldn't verify token")
		return Response(http.StatusUnauthorized, Error{
			ErrorMessages: []Message{
				{
					Code:    "100",
					Message: "Unauthorized. Please check your credentials.",
				},
			},
		}), nil
	}

	// Get user profile to check if confirmed
	user := database_user.FindUserById(ctx, &content.ID)
	if user == nil {
		return Response(http.StatusUnauthorized, Error{
			ErrorMessages: []Message{
				{
					Code:    "101",
					Message: "No user found",
				},
			},
		}), nil
	}

	if user.Roles != database_user.ConfirmedUser {
		return Response(http.StatusForbidden, Error{
			ErrorMessages: []Message{
				{
					Code:    "100",
					Message: "Unauthorized. Only confirmed users can rent products.",
				},
			},
		}), nil
	}

	// Get product from database
	product := database_product.FindProductById(ctx, productId)
	if product == nil || product.IsRented {
		return Response(http.StatusNotFound, Error{
			ErrorMessages: []Message{
				{
					Code:    "200",
					Message: "Product is unavailable",
				},
			},
		}), nil
	}

	// Validate rental dates
	startDate, err := time.Parse(time.DateOnly, rentProductFormular.RentalStartDate)
	if err != nil {
		return Response(http.StatusBadRequest, Error{
			ErrorMessages: []Message{
				{
					Code:    "200",
					Message: "Invalid rental start date format",
				},
			},
		}), nil
	}

	endDate, err := time.Parse(time.DateOnly, rentProductFormular.RentalEndDate)
	if err != nil {
		return Response(http.StatusBadRequest, Error{
			ErrorMessages: []Message{
				{
					Code:    "200",
					Message: "Invalid rental end date format",
				},
			},
		}), nil
	}

	// Calculate total amount
	totalAmount := product.Pricing.Price * float32(endDate.Sub(startDate).Hours()/24)
	if product.Pricing.Deposit > 0 {
		totalAmount += product.Pricing.Deposit
	}

	// Create rent contract
	contract := database_rent_contract.CreateRentContract(
		ctx,
		productId,
		content.ID,
		rentProductFormular.RentalStartDate,
		rentProductFormular.RentalEndDate,
		product.Pricing.Price,
		product.Pricing.Deposit,
		totalAmount,
		rentProductFormular.PaymentMethodId,
		rentProductFormular.LocationId,
		rentProductFormular.LocationId,
		rentProductFormular.AdditionalNotes,
		rentProductFormular.DynamicAttributes,
	)

	if contract == nil {
		return Response(http.StatusInternalServerError, Error{
			ErrorMessages: []Message{
				{
					Code:    "001",
					Message: "Failed to create rent contract",
				},
			},
		}), nil
	}

	// Update product rental status
	product.IsRented = true
	product.RenterInfo = &database_product.RenterInfo{
		UserID:          content.ID,
		RentalStartDate: rentProductFormular.RentalStartDate,
		RentalEndDate:   rentProductFormular.RentalEndDate,
		Status:          string(database_rent_contract.RentContractStatusPending),
	}

	updatedProduct := database_product.UpdateProduct(ctx, product)
	if updatedProduct == nil {
		// Rollback rent contract creation
		database_rent_contract.DeleteRentContract(ctx, contract.ID, contract.Rev)
		return Response(http.StatusInternalServerError, Error{
			ErrorMessages: []Message{
				{
					Code:    "001",
					Message: "Failed to update product rental status",
				},
			},
		}), nil
	}

	return Response(http.StatusOK, RentProductConfirmation{
		RentContractId: contract.ID,
	}), nil
}

// ProfileGet - Get user profile
func (s *UserAPIService) ProfileGet(ctx context.Context, r *http.Request) (ImplResponse, error) {
	user, err := openapi_common.IsUserAuthorized(ctx, r)
	if err != nil {
		log.Error().Msg(err.Error())
		return Response(401, Error{ErrorMessages: []Message{{Code: "100", Message: "Unauthorized."}}}), nil
	}
	sanitized := database_user.SanitizeUserProfile(user)
	return Response(200, sanitized), nil
}

// RentalsRentContractIdPickupPost - Confirm product pickup
func (s *UserAPIService) RentalsRentContractIdPickupPost(ctx context.Context, rentContractId string, pickupConfirmation PickupConfirmation) (ImplResponse, error) {
	// TODO - update RentalsRentContractIdPickupPost with the required logic for this service method.
	// Add api_user_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Success{}) or use other options such as http.Ok ...
	// return Response(200, Success{}), nil

	// TODO: Uncomment the next line to return response Response(400, Error{}) or use other options such as http.Ok ...
	// return Response(400, Error{}), nil

	// TODO: Uncomment the next line to return response Response(401, Error{}) or use other options such as http.Ok ...
	// return Response(401, Error{}), nil

	// TODO: Uncomment the next line to return response Response(404, Error{}) or use other options such as http.Ok ...
	// return Response(404, Error{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("RentalsRentContractIdPickupPost method not implemented")
}

// RentalsRentContractIdReturnPost - Confirm product return
func (s *UserAPIService) RentalsRentContractIdReturnPost(ctx context.Context, rentContractId string, returnProduct ReturnProduct) (ImplResponse, error) {
	// TODO - update RentalsRentContractIdReturnPost with the required logic for this service method.
	// Add api_user_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Success{}) or use other options such as http.Ok ...
	// return Response(200, Success{}), nil

	// TODO: Uncomment the next line to return response Response(400, Error{}) or use other options such as http.Ok ...
	// return Response(400, Error{}), nil

	// TODO: Uncomment the next line to return response Response(401, Error{}) or use other options such as http.Ok ...
	// return Response(401, Error{}), nil

	// TODO: Uncomment the next line to return response Response(404, Error{}) or use other options such as http.Ok ...
	// return Response(404, Error{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("RentalsRentContractIdReturnPost method not implemented")
}
